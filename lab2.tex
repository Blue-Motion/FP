\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dutch]{babel}
\usepackage{color}
\usepackage{enumerate}
\usepackage{float}
\usepackage[margin=3cm]{geometry}
\usepackage{graphicx}
%\usepackage[hidelinks]{hyperref}
\usepackage{hyperref}
\usepackage{listings}
%\usepackage{subfig}
\usepackage{url}
%\usepackage[square]{natbib}

\definecolor{Gray}{gray}{0.9}
 
\lstset{language=Haskell,backgroundcolor=\color{Gray},basicstyle=\footnotesize,numberstyle=\footnotesize,numbers=left,stepnumber=1,numbersep=5pt,breaklines=true,frame=lines,tabsize=2}
 
\author{Thom Carretero Seinhorst (s1898760) \and Bart Offereins (s2255243)}
\date{\today}
\title{Functional programming \\Lab 2}

\begin{document}

  \maketitle
  
\section{Exercise 1}
\subsection{Problem}
Find the smallest number that can be divided by each of the numbers from 1 to $n$ without any remainder.\\
The function $smallestMultiple\: 10000$ should compute within one second.

\subsection{Solution}
The second half of the range is always twice the first half. So if we compute the product of the second half, is it always divisible by all first half elements.

\begin{lstlisting}
smallestMultiple n = div (prod [(h+1)..n]) (prod [3..(h-1)])
   where h = div n 2
         prod = foldr (*) 1
\end{lstlisting}
\subsection{Proof}

Runtime: 0.09 sec

\section{Exercise 2}
\subsection{Problem}
This problem is divided into three subproblems:\\
1. write a function $mults$ with input positif $n$ value, that produces the infinite list of multiples of $n$\\
2. Next, write function $mutiples$ that takes as its input a finite list of positive integers,
and produces the infinite list of multiples of these integers.\\
3. Create $multsum\: n\: xs$ that computes the sum of the multiples
of $xs$ below $n$\\
The function $multsum$ should not exceed two seconds.

\subsection{Solution}

\begin{lstlisting}
mults :: Integer -> [Integer]
mults n = [x * n | x <- [1..]]

multiples :: [Integer] -> [Integer]
multiples m = foldr merge [] (map mults m)

multsum :: Integer -> [Integer] -> Integer
multsum n xs = foldr (+) 0 (takeWhile (<n) (multiples xs))
\end{lstlisting}

\subsection{Proof}

Mults returns and infinite (ordered) list of multiples of x. Multiples maps this list to a list of inputs and generates the (ordered, infinite) lists for all elements. These lists are then ordered by merging them pairwise trough applying folder on merge. Returning an infinite ordered list of all multiples of the items of the input list, with duplicates removed. Multsum then takes as much elements as needed and computes the sum of the taken elements.

\section{Exercise 3}
\subsection{Problem}
There are two subproblems:\\
1. Create function $powers$ that takes as its input a positive integer $a$, and it produces the infinite
list of powers of $a$.\\
2. Next, write a Haskell function $distinctPowers$ that takes as its input two positive integers $m$ and
$n$, and produces the number of distinct terms in the sequence generated by $a^b$ for $2 \leq a \leq m$ and $2 \leq b \leq n$\\
The computation of $distinctPowers\: 100\: 1000$ should not take longer than 5 seconds.
\subsection{Solution}

\begin{lstlisting}
powers :: Integer -> [Integer]
powers a = [a^n | n <- [2..]]

distinctPowers :: Integer -> Int -> Int
distinctPowers a b =  length (foldr merge [] (map ((take (b-1)) . powers) [2..a]))
\end{lstlisting}

\subsection{Proof}

\section{Exercise 4}
\subsection{Problem}
Write a function $numberOfPalindromicComposites$ that takes as its input a positive integer $n$, and
produces as its output the number of palindromic numbers $x$ which have the form $x=p*q<n$, where $p$
and $q$ are prime numbers.\\
The time to compute $numberOfPalindromicComposites\: (10^8)$ using ghci should not exceed
two seconds.

\subsection{Solution}

\begin{lstlisting}
numberOfPalindromicComposites :: Integer -> Int
numberOfPalindromicComposites n = length (filter (isPalindromeBelow) (composites n))
  where isPalindromeBelow c = c<n && isPalindrome c
        composites n = foldr merge [] [map (*x) ps | x <- ps]
        ps = listPrimes (div n 3)

isPalindrome :: (Show a) => a -> Bool
isPalindrome n = show n == (reverse . show) n
\end{lstlisting}

This solution relies heavily on the implementation of the function listPrimes. This is covered in the first lab exercise. However, we did not manage to create a version of listPrimes that is faster than the naive one. Thus the speed of our numberOfPalindromicComposites does not meet the requirements.

\subsection{Proof}

\section{Exercise 5}
\subsection{Problem}
Write a Haskell function lastDigits n d that computes the list of the last $d$ digits of the number
\begin{equation}
\sum\limits_{k=1}^n k^k
\end{equation}
\\
The time to compute $lastDigits\: (10^5)\: 10$ should not exceed five seconds

\subsection{Solution}

\begin{lstlisting}
lastDigits :: Integer -> Int -> [Integer]
lastDigits n d = drop (subtract d (length (toDigits nsum))) (toDigits nsum)
  where nsum = foldr (+) 0 ([expmod x x (10^(d+1)) | x <- [1..n]])

--http://hackage.haskell.org/package/hS3-0.5.8/docs/src/Codec-Encryption-RSA-NumberTheory.html
expmod :: Integer -> Integer -> Integer -> Integer
expmod a x m
  | x == 0 = 1
  | x == 1 = mod a m
  | even x =
    let p = (expmod a (mod (div x 2) m) m)
                            in  mod (p^2) m
  | otherwise = mod (a * expmod a (x-1) m)  m 
\end{lstlisting}

\subsection{Proof}

\section{Exercise 6}
\subsection{Problem}

\subsection{Solution}

\begin{lstlisting}
sumsg :: Integer -> Integer
sumsg n = sum (map sg [1..n])
      where
	f n = sum(map fac (toDigits n))
	g i = head [x | x <- [1..], sf x == i]
	s fun = sum . toDigits . fun
      	sg = s g
      	sf = s f

fac :: Integer -> Integer
fac n = foldr (*) 1 [1..n]
\end{lstlisting}

\subsection{Proof}

\section{Code}

\begin{lstlisting}
primes :: [Integer]
primes = 2 : filter ((==1) . length . primeFactors) [3,5..]
\end{lstlisting}

\begin{lstlisting}
primeFactors n = factor n primes
  where
    factor n (p:ps) 
      | p*p > n = [n]
      | mod n p == 0 = p : factor (div n p) (p:ps)
      | otherwise = factor n ps
\end{lstlisting}

\begin{lstlisting}
listPrimes :: Integer -> [Integer]
listPrimes x = takeWhile (< x) primes
\end{lstlisting}
\begin{lstlisting}
merge :: (Ord a) => [a] -> [a] -> [a]
merge xs [] = xs
merge [] ys = ys
merge (x:xs) (y:ys)
  | x < y = x : (merge xs (y:ys))
  | x == y = x : (merge xs ys)
  | otherwise = y : (merge (x:xs) ys)
\end{lstlisting}
\begin{lstlisting}
toDigits :: Integer -> [Integer]
toDigits x
	 | x < 10 = [x]
	 | otherwise = toDigits (div x 10) ++ [(mod x 10)]
\end{lstlisting}




\end{document}
