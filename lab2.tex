\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dutch]{babel}
\usepackage{color}
\usepackage{enumerate}
\usepackage{float}
\usepackage[margin=3cm]{geometry}
\usepackage{graphicx}
%\usepackage[hidelinks]{hyperref}
\usepackage{hyperref}
\usepackage{listings}
%\usepackage{subfig}
\usepackage{url}
%\usepackage[square]{natbib}

\definecolor{Gray}{gray}{0.9}
 
\lstset{language=Haskell,backgroundcolor=\color{Gray},basicstyle=\footnotesize,numberstyle=\footnotesize,numbers=left,stepnumber=1,numbersep=5pt,breaklines=true,frame=lines,tabsize=2}
 
\author{Thom Carretero Seinhorst (s1898760) \and Bart Offereins (s2255243)}
\date{\today}
\title{Functional programming \\Lab 2}

\begin{document}

  \maketitle
  
\section{Smallest multiple}
\subsection{Problem}
Find the smallest number that can be divided by each of the numbers from 1 to $n$ without any remainder.\\
The function $smallestMultiple\: 10000$ should compute within one second.

\subsection{Solution}
The second half of the range is always twice the first half. So if we compute the product of the second half, is it always divisible by all first half elements.

\begin{lstlisting}
smallestMultiple n = div (prod [(h+1)..n]) (prod [3..(h-1)])
   where h = div n 2
         prod = foldr (*) 1
\end{lstlisting}
\subsection{Proof}

Runtime: 0.09 sec

\section{Sum of multiples}
\subsection{Problem}
This problem is divided into three subproblems:\\
1. write a function $mults$ with input positif $n$ value, that produces the infinite list of multiples of $n$\\
2. Next, write function $mutiples$ that takes as its input a finite list of positive integers,
and produces the infinite list of multiples of these integers.\\
3. Create $multsum\: n\: xs$ that computes the sum of the multiples
of $xs$ below $n$\\
The function $multsum$ should not exceed two seconds.

\subsection{Solution}

\begin{lstlisting}
mults :: Integer -> [Integer]
mults n = [x * n | x <- [1..]]

multiples :: [Integer] -> [Integer]
multiples m = foldr merge [] (map mults m)

multsum :: Integer -> [Integer] -> Integer
multsum n xs = foldr (+) 0 (takeWhile (<n) (multiples xs))
\end{lstlisting}

\subsection{Proof}

Mults returns an infinite (ordered) list of multiples of x. Multiples maps this list to a list of inputs and generates the (ordered, infinite) lists for all elements. These lists are then ordered by merging them pairwise trough applying folder on merge. Returning an infinite ordered list of all multiples of the items of the input list, with duplicates removed. Multsum then takes as much elements as needed and computes the sum of the taken elements.\\
\\
Runtime: 1.78 s

\section{Distinct powers}
\subsection{Problem}
There are two subproblems:\\
1. Create function $powers$ that takes as its input a positive integer $a$, and it produces the infinite
list of powers of $a$.\\
2. Next, write a Haskell function $distinctPowers$ that takes as its input two positive integers $m$ and
$n$, and produces the number of distinct terms in the sequence generated by $a^b$ for $2 \leq a \leq m$ and $2 \leq b \leq n$\\
The computation of $distinctPowers\: 100\: 1000$ should not take longer than 5 seconds.
\subsection{Solution}

\begin{lstlisting}
powers :: Integer -> [Integer]
powers a = [a^n | n <- [2..]]

distinctPowers :: Integer -> Int -> Int
distinctPowers a b =  length (foldr merge [] (map ((take (b-1)) . powers) [2..a]))
\end{lstlisting}

\subsection{Proof}
The function powers creates an infinite list of powers of a. The last part of the function distinctpowers creates a list of lists with the number of distinct term generated by $a^b$.
\begin{lstlisting}
[[4,8,16,32],[9,27,81,243],[16,64,256,1024],[25,125,625,3125]
\end{lstlisting}
This example is with $a$ = 5 and $b$ = 5.\\
These lists are then ordered by merging them pairwise trough applying folder on merge.\\
\\
distinctpowers 100 1000 = 92628\\
Runtime:4.41s

\section{Palindromic Composite}
\subsection{Problem}
Write a function $numberOfPalindromicComposites$ that takes as its input a positive integer $n$, and
produces as its output the number of palindromic numbers $x$ which have the form $x=p*q<n$, where $p$
and $q$ are prime numbers.\\
The time to compute $numberOfPalindromicComposites\: (10^8)$ using ghci should not exceed
two seconds.

\subsection{Solution}

\begin{lstlisting}
numberOfPalindromicComposites :: Integer -> Int
numberOfPalindromicComposites n = length (filter (isPalindromeBelow) (composites n))
  where isPalindromeBelow c = c<n && isPalindrome c
        composites n = foldr merge [] [map (*x) ps | x <- ps]
        ps = listPrimes (div n 3)

isPalindrome :: (Show a) => a -> Bool
isPalindrome n = show n == (reverse . show) n
\end{lstlisting}

This solution relies heavily on the implementation of the function listPrimes. This is covered in the first lab exercise. However, we did not manage to create a version of listPrimes that is faster than the naive one. Thus the speed of our numberOfPalindromicComposites does not meet the requirements.


\section{Last n digits}
\subsection{Problem}
Write a Haskell function lastDigits n d that computes the list of the last $d$ digits of the number
\begin{equation}
\sum\limits_{k=1}^n k^k
\end{equation}
\\
The time to compute $lastDigits\: (10^5)\: 10$ should not exceed five seconds

\subsection{Solution}

\begin{lstlisting}
lastDigits :: Integer -> Int -> [Integer]
lastDigits n d = drop (subtract d (length (toDigits nsum))) (toDigits nsum)
  where nsum = foldr (+) 0 ([expmod x x (10^(d+1)) | x <- [1..n]])

--http://hackage.haskell.org/package/hS3-0.5.8/docs/src/Codec-Encryption-RSA-NumberTheory.html
expmod :: Integer -> Integer -> Integer -> Integer
expmod a x m
  | x == 0 = 1
  | x == 1 = mod a m
  | even x =
    let p = (expmod a (mod (div x 2) m) m)
                            in  mod (p^2) m
  | otherwise = mod (a * expmod a (x-1) m)  m 
\end{lstlisting}

\subsection{Proof}
We used the function expmod from the website haskell.org, expmod calculates $a^x\: (mod\: m)$.\\ 
The function nsum sums the numbers for $a^x\: (mod\: m)$. The last d numbers will be transformed into a list of digits using drop and and substract. For the function toDigits, see the Helper Function chapter.\\
\\ 
Runtime: 4.81 s

\section{Factorial Sum}
\subsection{Problem}

Define f(n) as the sum of the factorials of the digits of n. For example, f(342) = 3!  + 4!  + 2!  = 32.

Define sf(n) as the sum of the digits of f(n). So sf(342) = 3 + 2 = 5.

Define g(i) to be the smallest positive integer n such that sf(n) = i. Though sf(342) is 5, sf(25)
is also 5,  and it can be verified that g(5) is 25.

Define sg(i) as  the  sum  of  the  digits  of g(i).   So sg(5) = 2 + 5 = 7 . It  can  be  veried  that sg(1)+sg(2)+..+sg(20) is 156.

Write a Haskell function sumsg n that returns sg(1)+sg(2)+..+sg(n).
\subsection{Solution}

\begin{lstlisting}
sumsg :: Integer -> Integer
sumsg n = sum (map sg [1..n])
      where
	f n = sum(map fac (toDigits n))
	g i = head [x | x <- [1..], sf x == i]
	s fun = sum . toDigits . fun
      	sg = s g
      	sf = s f

fac :: Integer -> Integer
fac n = foldr (*) 1 [1..n]
\end{lstlisting}

\subsection{Proof}
$f\: n$ calculates the sum of the factorials of the digits of n, $toDigits$ is the same function as in exersize 5. \\
s is a function that takes a function fun as an argument. It takes the digits of the result of this fuctions and sums them.

\section{Helper functions}

\subsection{listPrimes}
Listprimes and functions needed for listPrimes are covered in the report of lab1.

\subsection{merge}

Merge takes to ordered lists and combines them into one ordered list, removing any duplicates.

\begin{lstlisting}
merge :: (Ord a) => [a] -> [a] -> [a]
merge xs [] = xs
merge [] ys = ys
merge (x:xs) (y:ys)
  | x < y = x : (merge xs (y:ys))
  | x == y = x : (merge xs ys)
  | otherwise = y : (merge (x:xs) ys)
\end{lstlisting}

\subsection{toDigits}

ToDigits takes and integer as an input and yield an Integer list of all digits form the input.

\begin{lstlisting}
toDigits :: Integer -> [Integer]
toDigits x
	 | x < 10 = [x]
	 | otherwise = toDigits (div x 10) ++ [(mod x 10)]
\end{lstlisting}


\end{document}
